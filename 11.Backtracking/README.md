# 4-ти януари 2024г.

## Backtraking - задачи за навигиране в двуизмерен лабиринт

#### Същност
Това са задачи, където ни е дадена карта под формата на двуизмерен масив. В масива има проходими и непроходими полета и "съкровище". Нашата цел е да намерим път от дадена начална точка до "съкровището", като можем да минаваме само по проходимите полета.

Всяка подобна задача дефинира по някакав начин понятията:  
1. Начална точка - може да е зададена с конкретни кординати, може да е поле със стойност за начало (пример: 's'), което трябва да намерим къде е, или просто да е казано, че започваме от някой ъгъл на матрицата.  
2. Проходими и непроходими клетки - най-често тези два типа клетки се дефинират с някакви различаващи се стойности. Пример: 
- '1' - проходима, '0' - непреходима
- '_'- свободен път(прохидима), '#' - стена(непроходима), '$'- чудовище (непроходима).
3. Как можем да се предвижваме от преходимите клетки - тук се описва как от една клетка можем да преминем в друга. Най-често обхождаме 4-те съседни и/или клетките, които се намират по диагонал.
4. "Съкровище" - най-често се дефинира чрез някакъв символ, който присъства само веднъж в двумерния масив. 


#### Типове задачи
1. Проверка дали има път от началната точка до съкровището.
2. Намиране на някакъв път от началната точка до съкровището.
3. Намиране на всички пътища от началната точка до съкровището.
4. Намиране на най-кратък/най-дълъг път.


#### Общ вид на алгоритъма
Когато търсим какъвто и да е път
```
bool/int findPath(<картата>, <текущата_клетка>, <цел>, [<път>, <текущата_дължина>]) {
    if(<проверка дали сме на валидна и проходима клетка>) {
        return <отрицателен резултат>; // лъжа, ако търсим дали има път, или -1, ако търсим самия път
    }

    if(<проверка дали сме стигнали целта>) {
        return <положителен резултат>; // истина, ако търсим дали има път, или дължината на пътя, ако търсим самия път
    }

    <маркираме текущата клетка за посетена/непроходима>

    <чрез рекурсия проверяваме дали от клетките, към които можем да продължим, има път до целта>
}
```

Когато търсим всички пътища
```
bool/int findPath(<картата>, <текущата_клетка>, <цел>, [<път>, <текущата_дължина>]) {
    if(<проверка дали сме на валидна и проходима клетка>) {
        return;
    }

    if(<проверка дали сме стигнали целта>) {
        <принтираме или запазваме намерения път>
        return;
    }

    <маркираме текущата клетка за посетена/непроходима>

    <чрез рекурсия продължаваме да обхождаме клетките, 
    към които можем да продължим>

    <отмаркираме текущата клетка>
}
```