# 25-ти октомври 2023г.

## Функции 
-> Декларация
```
<връщан тип> <име-на-функцията>(<параметри>);
```
Пример: 
```
int getLastDigit(int number);
void printMsg();
```
-> Дефиниция
```
int getLastDigit(int number) {
    return number % 10;
}
void printMsg() {
    cout << "Hello User" << endl;
}
```
-> Извикване
```
int main() {
    printMsg();

    int a = 16;
    cout << getLastDigit(a) << endl;

    return 0;
}
```
-> Фактически и формални параметри  
-> Сигнатура на функция  
-> Подаване на параметрите по стойност и по указател

## Задачи за функции
#### 1. задача
В декартова координатна система по въведени абсциса и ордината на три точки определете дали в някоя от трите се образува прав ъгъл.

#### 2. задача
В декартова координатна система по въведени абсциса и ордината на четири точки определете дали образуват. Приемаме, че всички въведени точки ще  образуват изпъкнал четириъгълник:  
 а) Правоъгълник  
 б) Квадрат  

#### 3. задача
Нека решим [4-та задача](https://github.com/ivkaradzhova/Introduciton_to_programming_23_24/blob/main/3.%D0%A6%D0%B8%D0%BA%D0%BB%D0%B8%D1%87%D0%BD%D0%B8-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B8/README.md#4%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0) и [5-та задача](https://github.com/ivkaradzhova/Introduciton_to_programming_23_24/blob/main/3.%D0%A6%D0%B8%D0%BA%D0%BB%D0%B8%D1%87%D0%BD%D0%B8-%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B8/README.md#4%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0)  от седмица 3, използвайки по-семпли функции.


## Assert, throw, try, catch
### Assert
```
assert(<условие>);
```
-> Прекратява изпълнението на програмата ако условието не е изпълнено.

### throw
```
throw <exception>;
```
```
throw std::exception();
throw std::runtime_error("Dividing by 0");
```
-> `<exeption>` e променлива от тип std::exception или негов подклас. Всички класове от exceptions може да намерите [тук](https://en.cppreference.com/w/cpp/error/exception).

### try-catch
```
try {
    <код, който може да хвърли грешка>
} catch (<exception>) {
    <код, който се изпълнява след като сме получили грешка от тип <exception> >
} [ catch (<exception>) {
    ...
}
.
.
.
]
```

```
void func() {
    throw std::exception("Some issue");
}

int main () {
    try {
        func();
    } catch (const std::exception& e) {
        cout << "Error while executing func :"
            << e.what() << endl;
    }
}

```
## Задачи за хвърляне на грешки
### 1. задача
Напишете функция `int toInt(char symbol)`, която приема като параметър символ и го преобразува в цифра. В случай, че на символа не съответства цифра върнете грешка.
Пример:    
'4' -> 4  
'5'-> 5  
'g' -> error  
 
### 2. задача
По въведени абсциса и ордината на 4 точки, изведете лицето на правоъгълника, който образуват. В случай, че не образуват правоъгълник хвърлете грешка.

### 3. задача
Напишете програма калкулатор, която чете от стандартния вход операция (+, -, *, /) и две цели неотрицателни числа и извежда резултата от прилагането на операцията върху двете числа. Хвърлете грешка, ако е невъзможно прилагането на операцията:
- има делене на 0
- получава се overflow или underflow на типа


## Валидация на вход

## Указатели
### Оператор &
-> Взима адреса на променливата  
-> Пример:
```
int num = 546;
cout << num << endl; // 256
cout << &num << endl; // 0x7ff7b909f0c8 шестнадесетично число, което представлява номера на клетката в паметта, в която е записана num 
```

### Указатели
-> Променливи, които пазят адрес на друг обект.  
-> nullptr = нулев указател, т.е. указател, който не сочи към никой адрес
```
<тип>* <име> [=<адрес в паметта>];
```
```
int a = 5;
int* a_ptr = &a; //указател към адреса на 

int* b_ptr = nullptr; //нулев указател
int b = 6;
b_ptr = &b 
```
### Константни указатели и константи
```
int * const ptr; // константен указател

const int * ptr; // указател към константа
int const * ptr; // указател към константа

const int * const ptr; // константен указател към константа
```

-> Как да го запомним:  
- Винаги ако има `*` е пред `const` => константен указател
- Ако между типа и `const` няма `*` => имаме константа

### Указателна аритметика 